{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IVotationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IVotationManager\n * @notice Interfaccia per la gestione di elezioni decentralizzate\n * @dev Definisce le funzionalità core per creare elezioni, gestire i voti e verificare i risultati\n  * @author exo404, simonemontella, valeriooconte\n */\ninterface IVotationManager {\n\n    ///////////////////// DATA STRUCTURES /////////////////////\n    \n    /**\n     * @notice Struttura che rappresenta un'elezione\n     * @dev Contiene tutti i dati necessari per identificare e gestire un'elezione\n     * @param id ID univoco dell'elezione\n     * @param name Nome descrittivo dell'elezione\n     * @param startTime Timestamp di inizio dell'elezione\n     * @param endTime Timestamp di fine dell'elezione\n     * @param isActive Stato dell'elezione\n     */\n    struct Votation {\n        uint256 id;\n        string name;\n        uint256 startTime;\n        uint256 endTime;\n        bool isActive;\n        uint256[] candidates; \n    }\n\n    ///////////////////// EVENTS /////////////////////\n\n    /**\n     * @notice Emesso quando viene creata una nuova elezione\n     * @param votationId ID univoco della nuova elezione\n     * @param name Nome dell'elezione\n     * @param startTime Timestamp di inizio dell'elezione\n     * @param endTime Timestamp di fine dell'elezione\n     */\n    event VotationCreated(uint256 indexed votationId, string name, uint256 startTime, uint256 endTime);\n\n    /**\n     * @notice Emesso quando un'elezione viene avviata\n     * @param votationId ID dell'elezione avviata\n     * @param name Nome dell'elezione avviata\n     * @param endTime Timestamp di fine dell'elezione\n     */\n    event VotationStarted(uint256 indexed votationId, string name, uint256 endTime);\n\n    /**\n     * @notice Emesso quando un'elezione viene chiusa\n     * @param votationId ID dell'elezione chiusa\n     * @param name Nome dell'elezione chiusa\n     */\n    event VotationClosed(uint256 indexed votationId, string name);\n\n    /**\n     * @notice Emesso quando un voto viene registrato\n     * @param votationId ID dell'elezione per cui è stato espresso il voto\n     * @param voter Indirizzo del votante\n     */\n    event VoteCast(uint256 indexed votationId, address indexed voter);\n    \n    /**\n     * @notice Emesso quando un voto viene verificato con successo\n     * @param votationId ID dell'elezione per cui è stato verificato il voto\n     * @param voter Indirizzo del votante verificato\n     */\n    event VoteVerified(uint256 indexed votationId, address indexed voter);\n\n    \n    ///////////////////// ERRORS /////////////////////\n\n    /**\n     * @notice Errore lanciato quando si tenta di creare un'elezione con ID già esistente\n     * @param votationId ID dell'elezione che già esiste\n     */\n    error VotationAlreadyExists(uint256 votationId);\n    \n    /**\n     * @notice Errore lanciato quando si tenta di accedere a un'elezione inesistente\n     * @param votationId Id ID dell'elezione non trovata\n     */\n    error VotationNotFound(uint256 votationId);\n\n    /**\n     * @notice Errore lanciato quando si tenta di avviare un'elezione già attiva\n     * @param votationId ID dell'elezione già attiva\n     */\n    error VotationAlreadyActive(uint256 votationId);\n\n    /**\n     * @notice Errore lanciato quando si tenta di operare su un'elezione non attiva\n     * @param votationId ID dell'elezione non attiva\n     */\n    error VotationNotActive(uint256 votationId);\n\n    /**\n     * @notice Errore lanciato quando si tenta di creare un'elezione con un intervallo di tempo non valido\n     */\n    error InvalidTimeInterval();\n\n    /**\n     * @notice Errore lanciato quando si tenta di creare un'elezione con un nome vuoto\n     */\n    error InvalidName();\n\n    /**\n     * @notice Errore lanciato quando si tenta di votare fuori dalla finestra temporale consentita\n     * @param votationId ID dell'elezione per cui la finestra di voto è chiusa\n     */\n    error VotingWindowClosed(uint256 votationId);\n    \n    /**\n     * @notice Errore lanciato quando si specifica un candidato non valido\n     * @param candidateId ID del candidato non valido\n     */\n    error InvalidCandidate(uint256 candidateId);\n    \n    /**\n     * @notice Errore lanciato quando si esprime un voto non valido\n     */\n    error InvalidVote();\n\n    /**\n     * @notice Errore lanciato se tenta la verifica di un voto con un contratto di verifica non valido\n     */\n    error InvalidVerifierAddress();\n\n\n    ///////////////////// FUNCTIONS /////////////////////\n\n    /**\n     * @notice Crea una nuova elezione\n     * @dev La funzione deve verificare che i parametri siano validi e che l'elezione non esista già\n     * @param _newVotation Struttura contenente i dati dell'elezione da creare\n     */\n    function createVotation(Votation memory _newVotation) external;\n\n    /**\n     * @notice Chiude un'elezione esistente\n     * @dev Deve verificare che l'elezione sia attiva e che l'ID sia valido\n     * @param votationId ID dell'elezione da chiudere\n     */\n    function startVotation(uint256 votationId) external;\n\n    /**\n     * @notice Esprime un voto per un candidato in una specifica elezione\n     * @dev Deve verificare che l'elezione sia attiva, che sia nella finestra temporale corretta,\n     *      che il candidato sia valido e che il votante non abbia già votato\n     * @param votationId ID dell'elezione per cui votare\n     * @param candidateId ID del candidato per cui votare\n     * @param a Parametro della prova zk-SNARK\n     * @param b Parametro della prova zk-SNARK\n     * @param c Parametro della prova zk-SNARK\n     * @param input Input della prova zk-SNARK\n     * @param verifyContract Indirizzo del contratto di verifica della prova zk-SN\n     */\n    function vote(\n    uint256 votationId, uint256 candidateId,\n    uint[2] calldata a,\n    uint[2][2] calldata b,\n    uint[2] calldata c,\n    uint[3] calldata input,\n    address verifyContract\n    ) external;\n\n    /**\n     * @notice Verifica se un voto è stato correttamente registrato\n     * @dev Funzione di sola lettura per verificare l'integrità del voto\n     * @param a Parametro della prova zk-SNARK\n     * @param b Parametro della prova zk-SNARK\n     * @param c Parametro della prova zk-SNARK\n     * @param input Input della prova zk-SNARK\n     * @param verifyContract Indirizzo del contratto di verifica della prova zk-SN\n     * @return true se il voto è valido e correttamente registrato, false altrimenti\n     */\n    function verifyVote(    \n    uint[2] calldata a,\n    uint[2][2] calldata b,\n    uint[2] calldata c,\n    uint[3] calldata input,\n    address verifyContract) external returns (bool);\n\n    /**\n     * @notice Restituisce i risultati di un'elezione\n     * @dev Può essere chiamata solo per elezioni esistenti\n     * @param votationId ID dell'elezione di cui ottenere i risultati\n     * @return candidateIds Array degli ID dei candidati\n     * @return votes Array del numero di voti ricevuti da ciascun candidato (stesso ordine di candidateIds)\n     */\n    function votationResults(uint256 votationId) external view returns (uint256[] memory candidateIds, uint256[] memory votes);\n\n    /**\n     * @notice Verifica se una elezione è attualmente nella finestra temporale di voto\n     * @dev Controlla che l'orario corrente sia tra startTime e endTime e che l'elezione sia attiva\n     * @param votationId ID dell'elezione da verificare\n     * @return true se è possibile votare, false altrimenti\n     */\n    function checkVotingWindow(uint256 votationId) external view returns (bool);\n\n    /**\n     * @notice Restituisce i dettagli di un'elezione specifica\n     * @dev Funzione di sola lettura per ottenere informazioni complete su un'elezione\n     * @param votationId ID dell'elezione di cui ottenere i dettagli\n     * @return Votation struct contenente tutti i dati dell'elezione\n     */\n    function getVotation(uint256 votationId) external view returns (Votation memory);\n}"
    },
    "contracts/verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 18175675595163848758984695984219199250058529412191788787489038604522751662180;\n    uint256 constant deltax2 = 3193422583918397487593575066156270343425625293339149546692140626625999080158;\n    uint256 constant deltay1 = 17797080033332088019214997634942647620600327345744630304758599316692834572183;\n    uint256 constant deltay2 = 7067596232964131616445083656778252446771494634867421522112705555047565787990;\n\n    \n    uint256 constant IC0x = 3214699294573097669377599346337205815820690075877834070934071518673753970360;\n    uint256 constant IC0y = 82009830299263198854804928752421322214133922922685759153773591847960422781;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, r)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    },
    "contracts/VotationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IVotationManager} from \"./interfaces/IVotationManager.sol\";\nimport {Groth16Verifier} from \"./verifier.sol\";\n\n/**\n * @title VotationManager\n * @notice Implementazione dell'interfaccia IVotationManager per la gestione delle elezioni\n * @dev Fornisce funzionalità per creare, chiudere elezioni e gestire i voti\n * @author exo404, simonemontella, valeriooconte\n */\ncontract VotationManager is IVotationManager {\n    /*\n     * @notice Mapping che associa l'ID di un'elezione alla sua struttura dati\n     * @dev Per memorizzare le elezioni create\n     */\n    mapping(uint256 => Votation) public votations;\n\n    /**\n     * @notice Mapping che associa l'ID di un'elezione al numero di voti per ciascun candidato\n     * @dev Per memorizzare i risultati delle elezioni\n     */\n    mapping(uint256 => mapping(uint256 => uint256)) public votationCandidatesVotes;\n\n    /// @inheritdoc IVotationManager\n    function createVotation(Votation memory _newVotation) external {\n        if (_newVotation.startTime >= _newVotation.endTime) revert InvalidTimeInterval();\n        if (block.timestamp < _newVotation.startTime || block.timestamp > _newVotation.endTime) revert InvalidTimeInterval();\n        if (bytes(_newVotation.name).length == 0) revert InvalidName();\n\n        _newVotation.isActive = false;\n        votations[_newVotation.id] = _newVotation;\n\n        emit VotationCreated(_newVotation.id, _newVotation.name, _newVotation.startTime, _newVotation.endTime);\n    }\n\n    /// @inheritdoc IVotationManager\n    function startVotation(uint256 votationId) external {\n        Votation storage votation = votations[votationId];\n\n        if (votation.id == 0) revert VotationNotFound(votationId);\n        if (votation.isActive) revert VotationAlreadyActive(votationId);\n\n        votations[votationId].isActive = true;\n\n        emit VotationStarted(votationId, votation.name, votation.endTime);\n    }\n\n    /// @inheritdoc IVotationManager\n    function vote(\n    uint256 votationId, uint256 candidateId, \n    uint[2] calldata a,\n    uint[2][2] calldata b,\n    uint[2] calldata c,\n    uint[3] calldata input,\n    address verifyContract\n    ) external {\n        Votation storage votation = votations[votationId];\n\n        if (votation.id == 0) revert VotationNotFound(votationId);\n        if (!votation.isActive) revert VotationNotActive(votationId);\n        if (!_checkVotingWindow(votationId)) revert VotingWindowClosed(votationId);\n\n        if (!_verifyVote(a, b, c, input, verifyContract)) revert InvalidVote();\n\n        votationCandidatesVotes[votationId][candidateId] += 1;\n        emit VoteCast(votationId, msg.sender);\n    }\n\n    /// @inheritdoc IVotationManager\n    function verifyVote(\n        uint[2] calldata a,\n        uint[2][2] calldata b,\n        uint[2] calldata c,\n        uint[3] calldata input,\n        address verifyContract\n    ) external returns (bool) {\n        return _verifyVote(a, b, c, input, verifyContract);\n    }\n\n    /// @inheritdoc IVotationManager\n    function votationResults(uint256 votationId) external view returns (uint256[] memory candidateIds, uint256[] memory votes) {\n        Votation storage votation = votations[votationId];\n\n        if (votation.id == 0) revert VotationNotFound(votationId);\n\n        uint256 candidateCount = votation.candidates.length;\n        uint256 candidateId;\n\n        votes = new uint256[](candidateCount);\n\n        for (uint256 i = 0; i < candidateCount; i++) {\n            candidateId = votation.candidates[i];\n            votes[i] = votationCandidatesVotes[votationId][candidateId];\n        }\n\n        return (votation.candidates, votes);\n    }\n\n    /// @inheritdoc IVotationManager\n    function checkVotingWindow(uint256 votationId) external view returns (bool) {\n        return _checkVotingWindow(votationId);      \n    }\n\n    /// @inheritdoc IVotationManager\n    function getVotation(uint256 votationId) external view returns (Votation memory) {\n        Votation storage votation = votations[votationId];\n\n        if (votation.id == 0) revert VotationNotFound(votationId);\n\n        return votation;\n    }\n\n    function _verifyVote(\n        uint[2] calldata a,\n        uint[2][2] calldata b,\n        uint[2] calldata c,\n        uint[3] calldata input,\n        address verifyContract\n    ) internal returns (bool) {\n        if (verifyContract == address(0)) revert InvalidVerifierAddress();\n        Groth16Verifier verifier = Groth16Verifier(verifyContract);\n        return verifier.verifyProof(a, b, c, input);\n    }\n\n    function _checkVotingWindow(uint256 votationId) internal view returns (bool) {\n        Votation storage votation = votations[votationId];\n\n        if (votation.id == 0) revert VotationNotFound(votationId);\n        if (!votation.isActive) revert VotationNotActive(votationId);\n\n        return (block.timestamp >= votation.startTime && block.timestamp <= votation.endTime);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}